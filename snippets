" ==============
" === Basics ===
" ==============
" Map leader key to the customary comma
" ...without overriding it.
" nmap , = \ " => not very useful
" vmap , = \ " => completely broken, do not use

" set history=1000 " already in vim-sensible
" filetype plugin indent on " already in vim-sensible
" syntax on " already in vim-sensible

" =================================
" ========= TMUX.CONF =============
" =================================
"
" # bind-key -n S-Up    select-pane -U
" # bind-key -n S-Down  select-pane -D
" # bind-key -n S-Left  select-pane -L
" # bind-key -n S-Right select-pane -R
" 
" " https://github.com/henrik/dotfiles/blob/24ddbd90f75a2383400ef2c912b9ab8a5d5e9fc8/bin/tmux-vim-select-pane
" Save this as tmux-vim-select-pane in ~/bin
" !/usr/bin/env bash
" 
" # Like `tmux select-pane`, but if Vim is running in the current pane it sends a
" # keystroke to Vim instead to let it decide whether it's going to switch windows
" # internally or switch tmux panes.
" #
" # https://gist.github.com/mislav/5189704
" 
" set -e
" 
" # gets the tty of active tmux pane
" active_tty="$(tmux list-panes -F '#{pane_active}#{pane_tty}' | grep '^1')"
" 
" # checks if there's a foreground Vim process in attached to that tty
" if ps c -o 'state=,command=' -t "${active_tty#1}" | grep '+' | grep -iE '\bvim?\b' >/dev/null ; then
" direction="$(echo "${1#-}" | sed -e 's/D/Down/' -e 's/U/Up/' -e 's/L/Left/' -e 's/R/Right/')";
"   # forward the keystroke to Vim
"   tmux send-keys C-$direction
" else
" tmux select-pane "$@"
" fi
" 
" # # Smart pane switching with awareness of vim splits. (M is Alt in gnome-terminal)
" # bind-key -n M-Up    run-shell 'tmux-vim-select-pane -U'
" # bind-key -n M-Down  run-shell 'tmux-vim-select-pane -D'
" # bind-key -n M-Left  run-shell 'tmux-vim-select-pane -L'
" # bind-key -n M-Right run-shell 'tmux-vim-select-pane -R' 
" 
" # smart pane switching with awareness of vim splits
" # bind -n C-h run "(tmux display-message -p '#{pane_current_command}' | grep -iq vim && tmux send-keys C-h) || tmux select-pane -L"
" # bind -n C-j run "(tmux display-message -p '#{pane_current_command}' | grep -iq vim && tmux send-keys C-j) || tmux select-pane -D"
" # bind -n C-k run "(tmux display-message -p '#{pane_current_command}' | grep -iq vim && tmux send-keys C-k) || tmux select-pane -U"
" # bind -n C-l run "(tmux display-message -p '#{pane_current_command}' | grep -iq vim && tmux send-keys C-l) || tmux select-pane -R"
" # bind -n C-\ run "(tmux display-message -p '#{pane_current_command}' | grep -iq vim && tmux send-keys 'C-\\') || tmux select-pane -l"

" ============================
" === Fix keys inside tmux ===
" ============================

" <http://stackoverflow.com/questions/16638962/sending-ctrl-right-to-vim-inside-tmux/16640087#16640087>
" 
" I got something working though I'm very much treading unknown territory here. 
" Perhaps someone else can fill in the rest.
" 
" The first difference I noticed when starting up Vim in the terminal and Vim 
" inside tmux was in their 'term' setting.
" 
" When asked :set term?, ordinary terminal Vim answered xterm-256color, but tmux 
" Vim answered screen. It's important to understand that the exact key codes 
" sent in the terminal depend on the type of the terminal.
" 
" One solution is simply to make tmux and Vim speak the same language. In tmux:
" 
"     set-option -gw xterm-keys on
"     bind-key -n C-Right send-keys C-Right
" 
" In Vim:
" 
"     :set term=xterm-256color
" 
" Now Vim and tmux understand each other's terminal key codes and your key strokes 
" will make it all the way to Vim.

" <http://sourceforge.net/p/tmux/tmux-code/ci/master/tree/FAQ>
" => * How do I make Ctrl-PgUp and Ctrl-PgDn work in vim?
" if &term == "screen"
"   set t_kN=^[[6;*~
"   set t_kN=[5~
"   set t_kP=^[[5;*~
" endif

" 
" map [1;6C <C-S-Right>
" map [1;6D <C-S-Left>
" map [1;6A <C-S-Up>
" map [1;6B <C-S-Down>

" map OD <Left>
" map OC <Right>
" map [D <C-Left>
" map [C <C-Right>
" map OA <Up>
" map OB <Down>
" map [A <C-Up>
" map [B <C-Down>

" map [1;2C <S-Right>
" map [1;2D <S-Left>
" map [1;2A <S-Up>
" map [1;2B <S-Down>

" map [1;5C <C-Right>
" map [1;5D <C-Left>
" map [1;5A <C-Up>
" map [1;5B <C-Down>

" Keybindings
" <Leader>v selects the last pasted text
" nnoremap <Leader>v `[V`]             " <Leader>v selects the just pasted text
" nnoremap <Leader>v V`]             " <Leader>v selects the just pasted text

"""""""""""""""
" Arrows keys "
"""""""""""""""
" Option 1:
" http://superuser.com/questions/401926/how-to-get-shiftarrows-and-ctrlarrows-working-in-vim-in-tmux/562437#562437
"
" Disable Background Color Erase (BCE) by clearing the t_ut terminal option
" (run :set t_ut= in Vim and then press Control+L to refresh the terminal's
" display) so that color schemes work properly when Vim is used inside tmux
" and GNU screen.
"
" This way, you can keep your TERM value as xterm-256color for proper key
" detection while also getting proper Vim color scheme rendering too
" set t_ut=
"
" Option 2: see the actual vim file here

" ============
" === Tabs ===
" ============
" http://stackoverflow.com/questions/102384/using-vims-tabs-like-buffers/3476411#3476411
" tab sball
" set switchbuf=usetab,split
" open every buffer in its own tab
" au BufAdd,BufNewFile,BufRead * nested tab sball
" autocmd BufAdd,BufNewFile * nested tab sball

" Tab navigation like in Firefox
" Notice that 'sbnext' and 'sbprevious' would reopen closed tabs instead.
" Used for the buffers instead.
" nnoremap <C-Pageup>   :tabprevious<cr>
" nnoremap <C-Pagedown> :tabnext<cr>
" inoremap <C-Pageup>   :tabprevious<cr>
" inoremap <C-Pagedown> :tabnext<cr>

" <http://stackoverflow.com/questions/2468939/how-to-let-tab-display-only-file-name-rather-than-the-full-path-in-vim>
" set guitablabel=\[%N\]\ %t\ %M

" ===========================================================
" === NOTE: Support for CTRL-S and CTRL-Q in the terminal ===
" ===========================================================
" Normally CTRL-S and CTRL-Q suspend and wake up the terminal output in
" terminal emulators (respectively freezing and unfreezing).
" Put this function in the .bashrc to allow instead passing the key combo
" through to vim.
" TODO it's probably better to use something different from `s` and `q` instead.
"
" vim() {
"   local STTYOPTS="$(stty --save)"
"   stty stop '' -ixoff # pass CTRL-S
"   stty start '' -ixon # pass CTRL-Q
"   command vim "$@"
"   stty "$STTYOPTS"
" }

" ===============
" === Buffers ===
" ===============

" ...next
" nnoremap <C-j> :bn<cr>
" ...previous
" nnoremap <C-k> :bp<cr>

" " ...with Alt key instead...
" nnoremap <A-Pagedown> :bn<CR>
" inoremap <A-Pagedown> :bn<CR>
" vnoremap <A-Pagedown> :bn<CR>
" nnoremap <A-Pageup>   :bp<CR>
" inoremap <A-Pageup>   :bp<CR>
" vnoremap <A-Pageup>   :bp<CR>

" ==================================
" === Move between split windows ===
" ==================================
" <http://vim.wikia.com/wiki/Switch_between_Vim_window_splits_easily>
" nmap <silent> <A-Up> :wincmd k<CR>
" nmap <silent> <A-Down> :wincmd j<CR>
" nmap <silent> <A-Left> :wincmd h<CR>
" nmap <silent> <A-Right> :wincmd l<CR>

" =================
" === Clipboard ===
" =================
" set clipboard=unnamedplus
" ctrl-v conflicts with visual block, and is not very useful anyway
" nnoremap <C-e> "+gP
" inoremap <C-e> <Esc>"+gPi
" TODO: not working
" nnoremap <Leader>o "+gP
" vnoremap <Leader>y "+y

" ========================================
" === External commands without prompt ===
" ========================================
" To make the shell interactive (to support local aliases) follow these steps:
" 1 - set the shell flags
" http://stackoverflow.com/questions/4642822/commands-executed-from-vim-are-not-recognizing-bash-command-aliases/4642855#4642855
" set shellcmdflag=-itc
" 2 - modify the execute line adding a call to "fg" (foreground vim)
"command! -nargs=1 Silent
"      \ | execute ':silent !'.<q-args>.'; fg'
"      \ | execute ':redraw!'

" ============================
" === Close all the buffers ===
" ============================
" https://github.com/bryankennedy/vimrc/blob/master/vimrc
" this does not work well because closes everything, and messes up badly with nerdtree for instance
" nnoremap bda :1,300 bd<CR>

" ===================
" === Real delete ===
" ===================
" nnoremap <C-f> "_dd
" This is not handy, because the leader has to be released to repeat the
" action.
" nnoremap <leader>d "_dd
" vnoremap <leader>d "_d

" TODO: does not work
" inoremap <A-d> <Esc>"_ddi

" =========================
" === Switch buffers... ===
" =========================
" ...as if they were tabs, for some Vim users
" nnoremap <S-h> :bp<CR>
" nnoremap <S-l> :bn<CR>

" ====================
" === Bubble lines ===
" ====================
" The following should not be used, has the disadvantage of deleting lines at the ends of the buffer.
" http://vimcasts.org/episodes/bubbling-text/
" " ...single lines
" nmap <C-Up> ddkP
" nmap <C-Down> ddp
" " ...multiple lines
" vmap <C-Up> xkP`[V`]
" vmap <C-Down> xp`[V`]

" http://reefpoints.dockyard.com/2013/09/26/vim-moving-lines-aint-hard.html
" Normal mode
" nnoremap <C-Down> :m .+1<CR>==
" nnoremap <C-Up> :m .-2<CR>==

" Insert mode
" inoremap <C-Down> <ESC>:m .+1<CR>==gi
" inoremap <C-Up> <ESC>:m .-2<CR>==gi

" Visual mode
" vnoremap <C-Down> :m '>+1<CR>gv=gv
" vnoremap <C-Up> :m '<-2<CR>gv=gv

" ==================================
" === Autowrite, Backup and Undo ===
" ==================================
" This probably won't work in the terminal.
" augroup save
"   autocmd!
"   autocmd FocusLost * wall
"   " or suppress warnings for untitled and read-only buffers
"   " au FocusLost * silent! wa
" augroup END
"
" set autowriteall

" Save swap and undo files elsewhere
" create the dirs if they don't exist, trick from
" <https://github.com/ahawkins/dotfiles/blob/master/vimrc>
" silent !mkdir ~/.vim/swap > /dev/null 2>&1
" silent !mkdir ~/.vim/undo > /dev/null 2>&1
" set backupdir=~/.vim/swap/
" set undodir=~/.vim/undo/
" set undofile " persistent-undo
" set noundofile

" ====================
" === Code folding ===
" ====================
" http://smartic.us/2009/04/06/code-folding-in-vim/
" fold based on syntax
" set foldmethod=syntax
" deepest fold is 7 levels
" set foldnestmax=7
" 2 columns is considered the minumum useful value, although 1 can still serve
" set foldcolumn=0
" no folds are closed when opening a file: can be done in two ways
" - option 1
" set nofoldenable
" - option 2
" set foldlevelstart=99
" set foldlevel=1

" " <http://learnvimscriptthehardway.stevelosh.com/chapters/38.html>
" function! ToggleFoldAndNumbers()
"   " Toggle line numbers
"   setlocal number!

"   " Toggle fold column
"   if &foldcolumn
"     setlocal foldcolumn=0
"   else
"     setlocal foldcolumn=2
"   endif
" endfunction

" nnoremap <leader>z :call ToggleFoldAndNumbers()<cr>

" ====================
" === View options ===
" ====================
" wrap long lines
" set wrap
" ensure newline and the end of file (the default anyway)
" set eol
" Colors of the vertical rulers
" " To set the colors in a terminal version of Vim, add the following to .vimrc:
" " To see the available color names, issue the command :help ctermbg.
" highlight ColorColumn ctermbg=DarkGray

" set cursorcolumn
" set virtualedit=all

" ==========================
" === Search and Replace ===
" ==========================
" Don't wrap around (don't start from the beginning when reached the end)
" set nowrapscan
" clear search results pressing space or with the return key
" (destroy all software trick) (but this interferes with Ack-vim, can't use
" enter to go to the result)
" nnoremap <CR> :nohlsearch<CR>

" ================================
" === Search visually selected ===
" ================================

" <http://amix.dk/vim/vimrc.html>
" Visual mode pressing * or # searches for the current selection
" vnoremap <silent> * :call VisualSelection('f')<CR>
" vnoremap <silent> # :call VisualSelection('b')<CR>
"
" function! VisualSelection(direction) range
"     let l:saved_reg = @"
"     execute "normal! vgvy"
"
"     let l:pattern = escape(@", '\\/.*$^~[]')
"     let l:pattern = substitute(l:pattern, "\n$", "", "")
"
"     if a:direction == 'b'
"         execute "normal ?" . l:pattern . "^M"
"     elseif a:direction == 'gv'
"         call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
"     elseif a:direction == 'replace'
"         call CmdLine("%s" . '/'. l:pattern . '/')
"     elseif a:direction == 'f'
"         execute "normal /" . l:pattern . "^M"
"     endif
"
"     let @/ = l:pattern
"     let @" = l:saved_reg
" endfunction

" =========================
" === Misc key mappings ===
" =========================
" Map :W to :update (save only when the buffer has been modified)
" Bad idea, because it will replace the letter 'W' with the word 'update'
" ANYWHERE in any command...
" cnoremap W update
" Map :Q to 'no op', effectively disabling it
" noremap Q <Nop>

" =============
" === CtrlP ===
" =============

" Custom ignore
" Examples:
"
" let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
" let g:ctrlp_custom_ignore = {
"   \ 'dir':  '\v[\/]\.(git|hg|svn)$',
"   \ 'file': '\v\.(exe|so|dll)$',
"   \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
"   \ }
" let g:ctrlp_custom_ignore = {
"   \ 'file': '\v(\.cpp|\.h|\.hh|\.cxx)@<!$'
"   \ }

" unlet g:ctrlp_custom_ignore " this might be required if the variable type changes

" ===========
" === Ack ===
" ===========
" launch ack on current word with leader+A
" TODO: not working
" nnoremap <leader>A :Ack!<cword>

" ================
" === NERDTree ===
" ================
" From the NERDTree Readme.
" always open NERDTree when opening a file
" autocmd vimenter * NERDTree
" always open NERDTree even when there is no file open
" autocmd vimenter * if !argc() | NERDTree | endif
" close NERDTree if it is the only vim buffer open
" autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
"
" the additional NerdTreeTabs plugin makes NerdTree play better with tabs
" map <leader>n <plug>NERDTreeTabsToggle<cr>

" =======================
" === MiniBufExplorer ===
" =======================
" let g:miniBufExplBuffersNeeded = 1 " open immediately, don't wait for a second buffer

" prevent MiniBufExplorer from overriding custom colours
" let g:did_minibufexplorer_syntax_inits = 1

" Custom colors for buffers...
" highlight MBENormal ctermfg=15
" highlight MBEChanged ctermfg=199
" highlight MBEVisibleNormal ctermfg=14
" highlight MBEVisibleChanged ctermfg=178
" highlight MBEVisibleActiveNormal ctermfg=40
" highlight MBEVisibleActiveChanged ctermfg=199

" Custom colors for buffers...
" ...NOT CHANGED and NOT VISIBLE
" autocmd ColorScheme * highlight MBENormal ctermfg=15
" ...CHANGED and NOT VISIBLE
" autocmd ColorScheme * highlight MBEChanged ctermfg=199
" ...NOT CHANGED and VISIBLE
" autocmd ColorScheme * highlight MBEVisibleNormal ctermfg=14
" ...CHANGED and VISIBLE
" autocmd ColorScheme * highlight MBEVisibleChanged ctermfg=178
" ...NOT CHANGED, VISIBLE and ACTIVE
" autocmd ColorScheme * highlight MBEVisibleActiveNormal ctermfg=40
" ...CHANGED, VISIBLE and ACTIVE
" autocmd ColorScheme * highlight MBEVisibleActiveChanged ctermfg=199

" === Experimental from http://zzapper.co.uk/vimtips.html ===
" visual searching
" search for visually highlighted text, doesn't work well as the chosen solution
" vmap // y/<C-R>"<CR>
" ..with spec chars
" vmap <silent> // y/<C-R>=escape(@", '\\/.*$^~[]')<CR><CR>

" Escape
http://peterodding.com/code/vim/profile/autoload/xolox/escape.vim
" Vim script
" Maintainer: Peter Odding <peter@peterodding.com>
" Last Change: August 31, 2010
" URL: http://peterodding.com/code/vim/profile/autoload/xolox/escape.vim

" pattern() -- convert a string into a :substitute pattern that matches the string literally {{{1

function! xolox#escape#pattern(string)
  if type(a:string) == type('')
    let string = escape(a:string, '^$.*\~[]')
    return substitute(string, '\n', '\\n', 'g')
  endif
  return ''
endfunction

" substitute() -- convert a string into a :substitute replacement that inserts the string literally {{{1

function! xolox#escape#substitute(string)
  if type(a:string) == type('')
    let string = escape(a:string, '\&~%')
    return substitute(string, '\n', '\\r', 'g')
  endif
  return ''
endfunction

" vim: ts=2 sw=2 et

